# №1
f=open("test.txt")#Открываем файл, который находиться в той же папке что и файл с кодом
s=list(map(int,f))#Создаём масив и записываем туда все числа из файла в формате int(т.e число, а не строкавая переменная)"map - изменяет тип данного с str на int, list - создаёт массив"
k=0
maxs=-10**10
for i in range(len(s)-1):# Запускаем цикл по массиву. Важно, что когда мы сравниваем пары, то должны вычитать 1 из len(s), чтобы не выйти за границы массива
    if (s[i]<0 and s[i+1]>=0) or (s[i]>=0 and s[i+1]<0):#Проверяем на то, что есть ли в паре чисел строго ОДНО отрицательное число. Важно, что оставшиеся число может быть равно 0
        if -min(s[i],s[i+1])>max(s[i],s[i+1]):#Сравниваем отрицательное число с неотрицательным
            k+=1#Если все условия есть, то эта пара подходит. Добавляем к счётчику 1
            maxs=max(s[i]+s[i+1],maxs)#Нужно найти максимальную сумму, поэтому сравниваем сумму пары и текущее максимальное значение
print(k,maxs)
f.close()#Закрываем файл
# №2
f=open("test.txt")#Открываем файл, который находиться в той же папке что и файл с кодом
s=[]#Создаём массив, где будем хранить все числа из файла
for i in f:
    s.append(int(i))#Добавляем в массив число из файла преводя его в int
k=0
maxs=-10**10
for i in range(len(s)-2):# Запускаем цикл по массиву. Важно, что когда мы сравниваем тройки, то должны вычитать 2 из len(s), чтобы не выйти за границы массива
    mas=[s[i],s[i+1],s[i+2]]#Создаём массив, состоящий из чисел тройки
    mas.sort()#Сортируем по возрастанию, чтобы понять можно ли составить из тройки прогрессию(sort()-это функция, которая сортирует элементы в массиве по возрастанию)
    if mas[1]-mas[0]==mas[2]-mas[1] and mas[0]!=mas[1] and mas[1]!=mas[2]:# Если разница между первым и вторым элементом будет совпадать с разницей между вторым и третим элементом, то можно составить прогессию. Также элементы не должны быть одинаковые, чтобы создать прогрессию, поэтому сравниваем их друг с другом
        k+=1#Если все условия есть, то эта тройка подходит. Добавляем к счётчику 1
        maxs=max(s[i]+s[i+1]+s[i+2],maxs)#Нужно найти максимальную сумму, поэтому сравниваем сумму тройки и текущее максимальное значение
print(k,maxs)
f.close()#Закрываем файл
# №3
f=open("test2.txt")#Открываем файл, который находиться в той же папке что и файл с кодом
s=list(map(int,f))#Создаём масив и записываем туда все числа из файла в формате int(т.e число, а не строкавая переменная)"map - изменяет тип данного с str на int, list - создаёт массив"
min_ch=10**10# min_ch - это самое маленькое чётное число в последовательности
for i in range(len(s)): # Цикл по всему массиву
    if s[i]%2==0:# Если при деление на 2 число даёт остаток 0, то оно чётное
        min_ch=min(s[i],min_ch)# Сравниваем число с текущим минимальным чётным числом
k=0
maxs=0
for i in range(len(s)-1):# Запускаем цикл по массиву. Важно, что когда мы сравниваем пары, то должны вычитать 1 из len(s), чтобы не выйти за границы массива
    if bin(s[i]).count("1")>min_ch or bin(s[i+1]).count("1")>min_ch:# Сначала переводим число в двоичную систему счисления с помощью функции bin(bin - функция, которая переводит число в двоичную систему в строковом формате), а потом с помощью функции count("1") считаем кол-во единиц среди числа(count() - функция, которая считает кол-во символов введёного в скобках в какой либо стринговой переменой), если первое число не подходит, то проверяем второе
        k+=1#Если все условия есть, то эта пара подходит. Добавляем к счётчику 1
        maxs=max(s[i]+s[i+1],maxs)#Нужно найти максимальную сумму, поэтому сравниваем сумму пары и текущее максимальное значение
print(k,maxs)
f.close()#Закрываем файл
